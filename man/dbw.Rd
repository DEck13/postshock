% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/DBW.R
\name{dbw}
\alias{dbw}
\title{Donor Balancing Weights (DBW)}
\usage{
dbw(
  X,
  dbw_indices,
  shock_time_vec,
  scale = FALSE,
  center = FALSE,
  sum_to_1 = TRUE,
  bounded_below_by = 0,
  bounded_above_by = 1,
  princ_comp_count = NULL,
  normchoice = "l2",
  penalty_normchoice = "l1",
  penalty_lambda = 0,
  Y = NULL,
  Y_lookback_indices = NULL,
  X_lookback_indices = NULL,
  inputted_transformation = base::identity
)
}
\arguments{
\item{X}{List of data.frame/matrix. First is target (\code{X[[1L]]});
the remaining are donors (\code{X[[2L]]} ... \code{X[[n+1L]]}). Rows = time,
columns = features.}

\item{dbw_indices}{Integer vector of feature columns to use.}

\item{shock_time_vec}{Integer vector, same length as \code{X}; each series
is truncated to rows \code{1:shock_i} before matching.}

\item{scale, center}{Logical; z-score/center features before matching.}

\item{sum_to_1}{Logical; if \code{TRUE}, enforce \code{sum(W)=1}.}

\item{bounded_below_by, bounded_above_by}{Numeric scalars; lower/upper bounds
for each weight (broadcast to all weights).}

\item{princ_comp_count}{\code{NULL} or positive integer; if not \code{NULL},
apply PCA and keep that many principal components.}

\item{normchoice}{Character; \code{"l1"} or \code{"l2"} distance.}

\item{penalty_normchoice}{Character; \code{"l1"} (LASSO) or \code{"l2"} (Ridge)
on weights.}

\item{penalty_lambda}{Numeric >= 0; regularization strength (0 = off).}

\item{Y}{Optional list (same length as \code{X}) of auxiliary features to merge.}

\item{Y_lookback_indices}{Optional integer vector/list; backward row indices
for Y (e.g., \code{c(1,2,5)} means last, 2nd last, 5th last).}

\item{X_lookback_indices}{Optional integer vector/list; backward row indices
for X. If \code{NULL}, use only the last pre-shock row.}

\item{inputted_transformation}{Function applied to each \code{Y[[i]]} before
merging; defaults to \code{base::identity}.}
}
\value{
A list with:
\itemize{
\item \code{opt_params}: numeric vector of donor weights (length = #donors)
\item \code{convergence}: \code{"convergence"} or \code{"failed_convergence"}
\item \code{loss}: final matching loss (L1 or L2)
}
}
\description{
Compute donor weights on pre-shock data so that a convex combination of
donors matches the target under L1/L2 distance. Supports PCA, sum-to-one,
box constraints, and L1/L2 regularization on weights.
}
\details{
With \code{sum_to_1=TRUE} and nonnegative bounds, \eqn{||W||_1 = 1}; L1
regularization on \eqn{||W||_1} is then a constant and does not change the
optimum. Use L2 if you want an effective penalty under simplex constraints.
}
\examples{
\donttest{
  set.seed(1)
  T <- 50; K <- 3
  target <- data.frame(x1=rnorm(T), x2=rnorm(T, 0.2), x3=rnorm(T,-0.1))
  donor1 <- data.frame(x1=rnorm(T, 0.1), x2=rnorm(T,-0.1), x3=rnorm(T, 0.3))
  donor2 <- data.frame(x1=rnorm(T,-0.2), x2=rnorm(T, 0.4), x3=rnorm(T, 0.0))
  X_list <- list(target, donor1, donor2)
  shock  <- c(40, 40, 40)

  out <- dbw(
    X = X_list, dbw_indices = 1:K, shock_time_vec = shock,
    center = TRUE, scale = TRUE,
    sum_to_1 = TRUE, bounded_below_by = 0, bounded_above_by = 1,
    normchoice = "l2",
    penalty_normchoice = "l2", penalty_lambda = 1e-2
  )
  out$opt_params; out$loss; out$convergence
}

}
